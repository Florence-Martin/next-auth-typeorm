import request from 'supertest';
import bcrypt from 'bcrypt';
import { AppDataSource } from '../lib/data-source';
import { User } from '../lib/entity/User';
import app from '../app';

beforeAll(async () => {
  // Initialisez la connexion à la base de données
  if (!AppDataSource.isInitialized) {
    await AppDataSource.initialize();
  }
});

afterAll(async () => {
  // Fermez la connexion à la base de données après les tests
  if (AppDataSource.isInitialized) {
    await AppDataSource.destroy();
  }
});

describe('Authentication', () => {
  it('should authenticate user with correct password', async () => {
    const userRepository = AppDataSource.getRepository(User);
    
    // Hachez le mot de passe avant de sauvegarder l'utilisateur
    const hashedPassword = await bcrypt.hash('password123', 10);
    
    const user = new User();
    user.email = 'testuser@example.com';
    user.password = hashedPassword; // Stockez le mot de passe haché
    user.name = 'Test User';
    await userRepository.save(user);

    // Simulez une requête de connexion
    const response = await request(app)
      .post('/api/auth')
      .send({ email: 'testuser@example.com', password: 'password123' });

    // Vérifiez que la connexion est réussie
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('token');
  });

  it('should reject authentication with incorrect password', async () => {
    const response = await request(app)
      .post('/api/auth')
      .send({ email: 'testuser@example.com', password: 'wrongpassword' });

    // Vérifiez que la connexion échoue
    expect(response.status).toBe(401);
  });
});